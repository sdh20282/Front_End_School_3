내가 하고 있는 것이 본질인가?
- 다른 곳에 에너지를 빼앗기지 말자

iframe
- muto랑 auto play는 쿼리에서 자동으로 가져가야 함
-- 소리가 안나와야 자동재생이 됨
-- 유튜브에서 막아놓음

audio
- 크롬에서 자동재생 막음
- js로 컨트롤해야함

video
- 동영상 자체를 로드할 경우 트래픽을 많이 잡아먹음

코덱과 포맷
- 코덱은 원본 영상을 편집하여 압축한 결과물
- 포맷은 코덱을 담아 재생 가능한 플레이어에 전달되는 컨테이너

여러개의 서버 존재, 주로 3개로 구분
- 웹 서버
-- 정적 파일을 서빙
-- php 같은 프로그래밍 언어도 처리하기는 함..
-- 서버 이미지
-- 동적 이미지 (사용자 이미지) 는 앱서버에서 관리하거나나 db에서 꺼내와야 함
--- 정확히는 웹 서버에서 html 파일을 제공하고 API 이미지 서버에서 이미지를 로드함 (부하 분산)

- 앱 서버
-- 두뇌 역할
-- id, pw가 입력되면 db에서 확인하고, 맞을 경우 로그인된 페이지를 웹 서버에 요청

- 데이터베이스
-- 데이터 저장
-- 이미지의 경우에는 이미지 경로만 저장, 이미지는 스토리지에 저장
--- 이미지를 db에 저장할 경우 db에는 텍스트 형태로 저장됨
--- 비효율적, db 목적에도 맞지 않음
--- 별도의 API 이미지 서버를 둠

- API 서버
-- API 제공
-- API는 손님(프로그램)이 주문할 수 있게 메뉴(명령 목록)를 정리하고, 주문(명령)을 받으면 요리사(응용프로그램)와 상호작용하여 요청된 메뉴(명령에 대한 값)를 전달, 쉽게 말해, API는 프로그램들이 서로 상호작용하는 것을 도와주는 매개체

- 웹, 앱, db가 하나의 서버일 수도 있음
-- 여러개일 수도 있음

- 서버
-- HTML 파일이나 필요한 데이터를 서빙해주는 역할
-- 24시간 돌아가는 컴퓨터
-- 대부분 IP 연결

- 로컬
-- 트래픽 확장이 어려움, 서버 확장이 어려움,  들어오는 트래픽 제한 (대역폭의 문제), 정전(서버 날아갈 수도, 클라우드 서버 같은 경우 UPS 존재)
-- 비용 (전기세 + 인터넷)
- 클라우드
-- 비용
-- 서버 확장, 이전 용이, IP할당받거나 도메인 연결 용이, HTTPS 인증 용이, ...


쿼리스트링
- url에서 ?뒤에 오는 정보들
- key, value 쌍으로 이루어짐
-- db에서 검사..?

form
- 정보를 입력하는 영역
- 전달 방식은 method에 속함
- 어디로 보낼지는 action

- 동작 방식
-- 웹 페이지에 있는 폼에 데이터 입력
-- 웹 페이지 내 액션이 일어나게 되면 데이터는 웹 서버로 이동
-- 웹 서버는 데이터를 처리하기 위해 앱을 호출
-- 필요에 따라 앱은 db로 데이터 전송
-- db에서 crud 작업이 일어나고 결과를 app으로, web으로 전송

- form에서는 c, r에 해당하는 post, get 밖에 사용할 수 없음
-- u, d는 각각 put, delete

- get 메소드
-- 쿼리스트링에 데이터가 노출됨
-- URL로 데이터를 전달할 때 사용 (file 같은 큰 파일, id와 pw 같은 민감한 데이터에서는 사용하지 않음)
- post 메소드
-- 보안이 필요한 데이터 전송
-- 패킷 안에 데이터를 캡슐화 해서 전달 (민감한 데이터, 큰 데이터 등)
-- url 끝에 메소드를 명시하여 put, delete를 사용하기도 함

- 왜 get 방식을 사용하는가
-- 공유 목적 (특정 개시물에 접근, post 방식의 경우에는 메인페이지로 이동)
-- get, post 방식을 각각 다른 함수로 처리할 수 있다

- get과 post
-- http라는 프로토콜(규약) 안에 있는 메소드 중에 get과 post가 존재
-- post가 꼭 생성은 아님, 데이터를 불러올 수 있음
-- 정해진 것은 없다!
-- 목적에 따라 다름
-- URL로 데이터를 전달할 것이냐 -> get, URL에 데이터가 노출되면 안되는 경우 -> post

input
- name이 중요
-- 서버에서 이것을 받아서 어떻게 처리할까에 대한 내용
- 쉐도우 돔
-- 기본 위젯 수정

- readonly 속성
-- 개발자 도구로 수정하면 뚫림
-- 프론트 엔드, 서버 단에서 검사
--- script에서 유효성 검증 / 난독화

- pattern 속성
-- 정규 표현식 들어감

label
- for 속성의 값을 input의 id를 맞춰야 함

select
- multiple 속성을 multiple로 설정할 경우 여러개의 option을 선택할 수 있음

fieldset
- form이 많을때 그룹화

버튼의 디폴드 값은 submit
- 제출이라 페이지가 새로고침됨

URL
- ? 뒤로는 쿼리스트링
-- key=value 쌍
- 쿼리스트링 뒤에 해쉬값
- 앞에 path

legend
- 반드시 fieldset의 첫번째 자식
- 해당 fieldset이 무엇을 하는지

button
- input과 비교
-- 버튼이 스타일을 적용하기 훨씬 편함
-- 가벼운 버튼의 경우 input의 버튼타입을 사용하기도 함

textarea

datalist
- select, option과 섞어서 사용

table
- thead, tbody 필수
-- 데이터 관련 동작

scope 속성
- 스크린 리더기에서 읽을 방향 지정

meta 표준
- https://opg.me


############################
css

마크업과 css를 분리할 것을 권장함

현업에서는 공통 css를 링크로
- 커스텀을 style로 하거나 마지막 링크로
-- 마지막 링크가 더 많음

만약 같은 요소에 inline방식과 외부 스타일,  내부 스타일 모두 적용된다면
- 가까운 '순서'로
-- 링크가 스타일보다 앞에 있으면 스타일이, 뒤에 있으면 링크가
- css 순서 계산법 존재

import 함부로 사용하지 말기
- 협업에서 좋지 않음
- 위에 다른 코드가 존재하면 안됨
- 다수의 css파일을 하나의 html파일에서 링크할때 너무 길어지는 문제가 있음
-- 분기를 발생시켜 주어야 함

웹 폰트 사용시 트래픽 문제
- 로고 같은 경우 다른 곳에서 사용되지 않음
-- 잘 사용하지 않는 폰트는 이미지로 처리해야 함
- 많이 사용되지 않는 폰트는 경량화
-- 주로 사용되는 문자열만
- 많이 사용되는 폰트는
-- CDN을 사용하기 보다 내부 API 서버나 로컬 서버에서 서빙
-- content delivery network

웹으로 이력서 만들면 가산점이 좋다







